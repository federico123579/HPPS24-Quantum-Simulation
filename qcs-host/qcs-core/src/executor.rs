//! This module collects executors, which are responsible for executing the instructions
//! generated by the scheduler.
//!
//! As for now there is only one executor, the `CpuExecutor`, which is responsible for
//! executing the instructions on the CPU.

use std::sync::{Arc, Mutex};

use hashbrown::HashMap;
use rayon::iter::{IntoParallelIterator, ParallelIterator};

use crate::{
    model::blocks::SpannedBlock,
    scheduler::{Instruction, InstructionOperand},
};

/// The `CpuExecutor` is responsible for executing the instructions on the CPU.
#[derive(Debug, Clone, Default)]
pub struct CpuExecutor {
    /// The memory of the executor, which is a map from the id of the block to the block itself.
    memory: Arc<Mutex<HashMap<usize, SpannedBlock>>>,
}

impl CpuExecutor {
    /// Creates a new `CpuExecutor`.
    pub fn new() -> Self {
        Self {
            memory: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Loads a block from memory or from the instruction.
    #[inline]
    fn load_block(&self, instruction: InstructionOperand) -> SpannedBlock {
        match instruction {
            InstructionOperand::Gate(gate) => gate.into(),
            InstructionOperand::Address(address) => {
                self.memory.lock().unwrap().remove(&address).unwrap()
            }
        }
    }

    /// Saves a block in memory.
    #[inline]
    fn save_block(&self, id: usize, block: SpannedBlock) {
        self.memory.lock().unwrap().insert(id, block);
    }

    /// Executes a single instruction, updating the memory meanwhile.
    fn execute_single(&self, instruction: Instruction) {
        let Instruction {
            id, first, second, ..
        } = instruction;

        let first_block = self.load_block(first);
        let second_block = self.load_block(second);

        let new_span = first_block.merged_span(&second_block);
        let first_block = first_block.adapt_to_span(new_span.clone());
        let second_block = second_block.adapt_to_span(new_span);

        let result = first_block * second_block;
        self.save_block(id, result);
    }

    /// Executes a list of instructions, returning the equivalent blocks after
    /// conducting all the operations.
    pub fn execute(&mut self, instructions: Vec<Instruction>) -> Vec<SpannedBlock> {
        // Parallel execution of all indipendent instructions.
        instructions.into_par_iter().for_each(|instruction| {
            self.execute_single(instruction);
        });
        self.memory
            .lock()
            .unwrap()
            .drain()
            .map(|(_, block)| block)
            .collect()
    }
}
